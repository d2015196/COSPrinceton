The client is able to verify if she is talking to the server by initiating a DH KeyExchange process. The client and server send their DH KeyExchange messages to each other, compute their shared key and the server then signs this shared key and sends it over to the client. Upon verification of this signature the client asserts that she is in fact talking to the server. Apart from this RSAKey signature that verifies the Integrity of the server connection, the fact that the server signs a shared key that is not public also protects the Integrity of the connection as any man in the middle would not have a (message, signed_message) pair that can be later used to impersonate the server. 

After such a verification upon construction of the SecureChannel object, either party can begin to send and receive messages. The encryption and decryption scheme that they use is that provided by the AuthEncryptor and AuthDecryptor classes. If the key used to encrypt/decrypt is known only to the two parties involved in the communication these classes ensure the Confidentiality and Integrity properties; they ensure Confideniality and Integrity for the messages encrypted and just Integrity for any information transmitted through the nonces. Thus if the client and the server have exclusive access to their symmetric key(s) their communication will be private and secure from any MITM attacks of altering messages or the order at which they arrive. Note that this last source of attack is avoided by the Integrity of the nonce guarantee by the AuthEncrypt/Decrypt classes. 
There will be one key for the server-as-speaker, client-as-listener way of communication and another for the server-as-listener and client-as-speaker way of communication. This avoids the attack in which the server sends a message with key A and nonce B, and the client then sends a message with the same key A and the same nonce B and an adversary gains some information about the messages sent. The keys are also changed after every message sent. 

Not only will there be two keys for each way of communication but a single connection between a client and a server will have keys that are likely to be different from any other client to server connection. This is enabled by the Random Java class which provides a source of randomness that is non-deterministic. If the source of randomness is deterministic every single connection will have the sequence of generated keys. This enables a client that has a connection with the server, say connection_A, to halfway through the communication between client_B and server (connection_B), break into this connection and impersonate the server. 
To prevent such an attack, the shared key resulting from the DH Exchange will be used to compute the keys for encryption and decryption. The first key is the shared key itself, and the second is the hash of the shared key. Note that these keys are known to only the server and client and that they are likely to be distinct from those in any other connection. This is so because the DH Exchange objects take in a Random() object instead of a PRGen(byte[] seed). As opposed to the PRGen, the Random() object picks its own seed every time. 

Also, I did not manage my implementation to change keys after a message sent. 
